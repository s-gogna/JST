digraph {
	translation_unit             -> translation_unit_option;
	translation_unit_option      -> {translation_unit_option, external_declaration};
	external_declaration         -> {function_definition, declaration};
	function_definition          -> {declaration_specifiers, declarator, declaration_list, compound_statement};
	declaration                  -> {declaration_specifiers, init_declarator_list};
	declaration_list             -> {declaration_list, declaration};
	declaration_specifiers       -> {declaration_specifiers, storage_class_specifier, type_specifier, type_qualifier};
	storage_class_specifier      -> {AUTO, STATIC, EXTERN, REGISTER, TYPEDEF};
	type_specifier               -> {VOID, CHAR, UNSIGNED, INT, SHORT, LONG, FLOAT, DOUBLE, SIGNED, UNSIGNED, struct_or_union_specifier, enum_specifier, TYPEID};
	type_qualifier               -> {CONST, VOLATILE};
	struct_or_union_specifier    -> {struct_or_union, identifier, struct_declaration_list};
	struct_or_union              -> {STRUCT, UNION};
	struct_declaration_list      -> {struct_declaration_list, struct_declaration};
	init_declarator_list         -> {init_declarator_list, init_declarator};
	init_declarator              -> {declarator, initializer};
	struct_declaration           -> {specifier_qualifier_list, struct_declarator_list};
	specifier_qualifier_list     -> {type_specifier, specifier_qualifier_list, type_qualifier};
	struct_declarator_list       -> {struct_declarator_list, struct_declarator};
	struct_declarator            -> {declarator, constant_expression};
	enum_specifier               -> {ENUM, identifier, enumerator_list};
	enumerator_list              -> {enumerator_list, enumerator};
	enumerator                   -> {identifier, constant_expression};
	declarator                   -> {pointer, direct_declarator};
	direct_declarator            -> {identifier, declarator, direct_declarator, constant_expression_option, parameter_type_list, identifier_list};
	pointer                      -> {TIMES, type_qualifier_list, pointer};
	type_qualifier_list          -> {type_qualifier_list, type_qualifier};
	parameter_type_list          -> {parameter_list, ELIPSIS};
	parameter_list               -> {parameter_list, parameter_declaration};
	parameter_declaration        -> {declaration_specifiers, declarator, abstract_declarator_option};
	identifier_list              -> {identifier_list, identifier};
	initializer                  -> {assignment_expression, initializer_list};
	initializer_list             -> {initializer_list, initializer};
	typename                     -> {specifier_qualifier_list, abstract_declarator};
	abstract_declarator          -> {pointer, direct_abstract_declarator};
	direct_abstract_declarator   -> {TODO_abstract_declarator};
	statement                    -> {labeled_statement, expression_statement, compound_statement, selection_statement, iteration_statement, jump_statement};
	labeled_statement            -> {identifier, statement, CASE, constant_expression, DEFAULT};
	expression_statement         -> {expression_option};
	compound_statement           -> {declaration_list, statement_list};
	statement_list               -> {statement_list, statement};
	selection_statement          -> {IF, expression, statement, ELSE, SWITCH};
	iteration_statement          -> {FOR, WHILE, LPAREN, expression_option, DO};
	jump_statement               -> {GOTO, identifier, CONTINUE, BREAK, RETURN, expression_option};
	expression_option            -> {expression};
	expression                   -> {assignment_expression, expression};
	assignment_expression        -> {conditional_expression, unary_expression, assignment_operator, assignment_expression};
	assignment_operator          -> {EQUALS, PLUSEQUALS, assignment_operator_etc};
	constant_expression          -> {conditional_expression};
	conditional_expression       -> {binary_expression, ternary_expression};
	binary_expression            -> {cast_expression, binary_expression, operator};
	operator                     -> {PLUS, MINUS, etc};
	cast_expression              -> {unary_expression, typename, cast_expression};
	unary_expression             -> {postfix_expression, unary_operator, unary_expression, cast_expression, typename};
	postfix_expression           -> {primary_expression, postfix_expression, expression, argument_expression_list, PERIOD, ARROW, identifier, PLUSPLUS, MINUSMINUS};
	primary_expression           -> {identifier, constant, string_literal expression};
	argument_expression_list     -> {argument_expression_list, assignment_expression};
	constant                     -> {ICONST, FCONST, CCONST};
	identifier                   -> {ID};
}
