\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
	\DeclareGraphicsExtensions{.png, .jpeg}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}

\title{JSTCC: A simple C Compiler \\ CS660: Compiler Construction}
\author{Janelle Blankenburg, Shubham Gogna, Terence Henriod}
\date{\today}

\begin{document}

\clearpage            % All of
\maketitle            % this,
\thispagestyle{empty} % removes the page number from the title page

\begin{abstract}
\noindent Over the course of the Fall 2015 semester we implemented a basic
compiler for the C programming language. The compiler is composed of a front-end
and a back-end, which interface through a psuedo-assembly language of our own
design (referred to as ``3 Address Code" or ``3AC"). The compiler translates
ANSI C to MIPS assembly that can be run using the Mips Assembly and Runtime 
Simulator (MARS).
\end{abstract}

\newpage
\section{Compiler Construction}
The goal of the course was to implement a basic, ANSI C compiler, oriented
toward learning compiler concepts and not necessarily something ``production
ready."




\section{Implementation}
\subsection{Overview}
The compiler was implemented in the Python3 programming language in order to
emphasize compiler concepts and code readability. A few third party libraries
are used, but the majority of the code and design is our own.

The team consisted of two graduate students (Janelle, Terence) and one
undergraduate (Shubham), and completed the graduate level requirements of the
course.

\subsection{Dependencies}
The following 3^{rd} party libraries were used:
  \begin{itemize}
  \item \textbf{bintrees}: A pure python balanced-tree data structure library.
                            Used to meet the requirement of using balanced
                            trees in the symbol table.

  \item \textbf{PLY}: Python Lex-Yacc. A pure python, tried and true Lex and 
                      Yacc implementation. these were used to implement the
                      scanner/tokenizer and the syntax driven parser.

  \item \textbf{pylru}: A python LRU cache implementation used to implement (in
                        part) register management in assembler output.
  \end{itemize}

\subsection{Scanning and Parsing}

\subsection{Abstract Syntax Tree}

\subsection{3AC}

\subsection{Assembler: MIPS}

\section{Compiler Capabilities}
The following items were requirements of the course:
  \begin{enumerate}
  \item Basic declarations and assignments.

  \item Simple arithmetic operations.

  \item Conditional statements (\texttt{if}, \texttt{else if}, \texttt{else}).

  \item \texttt{while} loops.

  \item One, two, and three dimensional arrays.

  \item Basic function calls with simple parameters.
  \end{enumerate}

Our compiler supports the following additional features:
  \begin{enumerate}
  \item \texttt{for} and \texttt{do... while} loops.

  \item Arbitrarily high dimensional arrays.

  \item Recursive function calls.

  \item Functions that accept arrays as parameters.

  \item Acceptance of ``fragmented strings", where string fragments such as
        \texttt{"hello" "world" "!"} are combined into a single string literal.
  \end{enumerate}

Additionally, the following optimizations are supported:
  \begin{enumerate}
  \item Constant folding.
  \end{enumerate}


\section{Future Work}
The following are features that, if given more time, are features that we would
like to or be able to implement. There are simple ones that would only take days
to implement, and complex ones that would require more effort.

\subsection{Simple}
  \begin{itemize}
  \item \textit{Flesh out floating point operations}. We made a start, but did
        not have time to see it through given that it was not a requirement
        of the course.

  \item \textit{Make use of floating point and string literals}. We have a good
        concept of how to do this, but since it was not a requirement we did
        not quite make it there.

  \item \textit{More minor optimizations}. We would like to implement other
        simple optimizations such as replacing multiplications or divisions
        by two with bit-shifting operations.

  \item \textit{Implement pointers}. We were very close in thought and effort
        to accomplishing this, but again, since it was not a requirement, we
        refocused our efforts elsewhere. 
  \end{itemize}

\subsection{Complex}
  \begin{itemize}
  \item \texttt{flesh out all basic language features}. It would have been good
        to implement ternary operators and \texttt{switch} statements, but given
        their redundancy to other language features, they would be more for 
        completeness and a bookkeeping exercise than an actual enhancement.

  \item \texttt{struct}s. These are the next step in a complete language and
        implementing them would be very informative about memory management
        concepts.

  \item \texttt{typedef}s. For both the convenience and the ``intellectual
        street cred."

  \item \textit{Function pointers}. To truly master the language, create a
        language capable of true generality, and to better understand code
        manipulation. 
  \end{itemize}

\section{Recommendations}
We would first recommend to anyone building a compiler in the future to make
use of a unit test framework. Unit testing as much of our code as possible,
even if it was just making sure that objects resulting from processes could
be stringified in a predictable manner or to evaluate if fatal errors occurred
in the code was instrumental in our progress. Being able to test things in an
automated manner saved many hours of strained eyes and tired fingers.

Second, we would recommend that compiler-implementing-students look to
real-world examples as much as possible. We drew inspiration from a library
called \textit{pycparser}, a python C parsing library, for most of the front-
end. This was helpful, but in retrospect, we wish we would have looked at an
established intermediate language such as \textit{LLVM} to model our 3AC after.
Also it may have provided the benefit of having an already-implemented back-end
to compare against.

\end{document}
